
#include <stdint.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>

uint8_t mod_inverse_AES(uint8_t a, uint8_t b) {
   int64_t s, r, old_s, old_r, q, t; 

   r = b; old_r = a; s = 0; old_s = 1;

   while (r) {
      q = old_r / r;
      t = r; r = (old_r - (q * r)); old_r = t;
      t = s; s = (old_s - (q * s)); old_s = t;
   }

   if (s < 0) {
      s += b;
   }

   return s;
}

#define XTIMES(bin) (bin&0x80?((bin<<1)^0x1b):(bin<<1))

uint8_t mod_mult(uint8_t x, uint8_t y) {
   uint8_t s = 0;
   while (y) {
      if (y&0x1) {
         s ^= x;
      }
      x = XTIMES(x);
      y>>=1;
   }
   return s;
}

uint8_t s_box_AES(uint8_t xy) {
   static const uint8_t S[16][16] = { { 0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76 },
                                      { 0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0 },
                                      { 0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15 },
                                      { 0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75 },
                                      { 0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84 },
                                      { 0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf },
                                      { 0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8 },
                                      { 0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2 },
                                      { 0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73 },
                                      { 0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb },
                                      { 0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79 },
                                      { 0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08 },
                                      { 0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a },
                                      { 0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e },
                                      { 0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf },
                                      { 0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16 } };
   return S[(xy&0xf0)>>4][xy&0x0f];
}

uint8_t inv_s_box_AES(uint8_t xy) {
   static const uint8_t S[16][16] = { { 0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb },
                                      { 0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb },
                                      { 0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e },
                                      { 0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25 },
                                      { 0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92 },
                                      { 0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84 },
                                      { 0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06 },
                                      { 0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b },
                                      { 0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73 },
                                      { 0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e },
                                      { 0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b },
                                      { 0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4 },
                                      { 0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f },
                                      { 0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef },
                                      { 0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61 },
                                      { 0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d } };
   return S[(xy&0xf0)>>4][xy&0x0f];
}


#define ROTWORD(x) (x<<8)|(x>>24)
#define SUBWORD(x) (s_box_AES(x&0x000000ff))|(s_box_AES((x&0x0000ff00)>>8))<<8|(s_box_AES((x&0x00ff0000)>>16))<<16|(s_box_AES((x&0xff000000)>>24))<<24
#define SUBBYTES(s) s[0]=SUBWORD(s[0]);s[1]=SUBWORD(s[1]);s[2]=SUBWORD(s[2]);s[3]=SUBWORD(s[3])
#define INVSUBWORD(x) (inv_s_box_AES(x&0x000000ff))|(inv_s_box_AES((x&0x0000ff00)>>8))<<8|(inv_s_box_AES((x&0x00ff0000)>>16))<<16|(inv_s_box_AES((x&0xff000000)>>24))<<24
#define INVSUBBYTES(s) s[0]=INVSUBWORD(s[0]);s[1]=INVSUBWORD(s[1]);s[2]=INVSUBWORD(s[2]);s[3]=INVSUBWORD(s[3])
#define SHIFTROWS(s) s[1]=(s[1]<<8)|(s[1]>>24);s[2]=(s[2]<<16)|(s[2]>>16);s[3]=(s[3]<<24)|(s[3]>>8)
#define INVSHIFTROWS(s) s[1]=(s[1]>>8)|(s[1]<<24);s[2]=(s[2]>>16)|(s[2]<<16);s[3]=(s[3]>>24)|(s[3]<<8)

inline void load_state(uint32_t * b, uint32_t * s) {
   s[0] = (b[3]&0xff000000)>>24|(b[2]&0xff000000)>>16|(b[1]&0xff000000)>>8|(b[0]&0xff000000);
   s[1] = (b[3]&0x00ff0000)>>16|(b[2]&0x00ff0000)>>8|(b[1]&0x00ff0000)|(b[0]&0x00ff0000)<<8;
   s[2] = (b[3]&0x0000ff00)>>8|(b[2]&0x0000ff00)|(b[1]&0x0000ff00)<<8|(b[0]&0x0000ff00)<<16;
   s[3] = (b[3]&0x000000ff)|(b[2]&0x000000ff)<<8|(b[1]&0x000000ff)<<16|(b[0]&0x000000ff)<<24;
}

void mix_columns(uint32_t * s) {
   uint8_t h = 0;
   uint32_t m = 0x000000ff;
   uint32_t o[4] = {0,0,0,0};
   for (int i = 0; i < 4; i++) {
      o[0] |= (mod_mult((s[0]&m)>>h,0x02)^mod_mult((s[1]&m)>>h,0x03)^((s[2]&m)>>h)^((s[3]&m)>>h))<<h;
      o[1] |= (((s[0]&m)>>h)^mod_mult((s[1]&m)>>h,0x02)^mod_mult((s[2]&m)>>h,0x03)^((s[3]&m)>>h))<<h;
      o[2] |= (((s[0]&m)>>h)^((s[1]&m)>>h)^mod_mult((s[2]&m)>>h,0x02)^mod_mult((s[3]&m)>>h,0x03))<<h;
      o[3] |= (mod_mult((s[0]&m)>>h,0x03)^((s[1]&m)>>h)^((s[2]&m)>>h)^mod_mult((s[3]&m)>>h,0x02))<<h;
      m <<= 8; h+=8;
   }
   s[0] = o[0]; s[1] = o[1]; s[2] = o[2]; s[3] = o[3];
}

void inv_mix_columns(uint32_t * s) {
   uint8_t h = 0;
   uint32_t m = 0x000000ff;
   uint32_t o[4] = {0,0,0,0};
   for (int i = 0; i < 4; i++) {
      o[0] |= (mod_mult((s[0]&m)>>h,0x0e)^mod_mult((s[1]&m)>>h,0x0b)^mod_mult((s[2]&m)>>h,0x0d)^mod_mult((s[3]&m)>>h,0x09))<<h;
      o[1] |= (mod_mult((s[0]&m)>>h,0x09)^mod_mult((s[1]&m)>>h,0x0e)^mod_mult((s[2]&m)>>h,0x0b)^mod_mult((s[3]&m)>>h,0x0d))<<h;
      o[2] |= (mod_mult((s[0]&m)>>h,0x0d)^mod_mult((s[1]&m)>>h,0x09)^mod_mult((s[2]&m)>>h,0x0e)^mod_mult((s[3]&m)>>h,0x0b))<<h;
      o[3] |= (mod_mult((s[0]&m)>>h,0x0b)^mod_mult((s[1]&m)>>h,0x0d)^mod_mult((s[2]&m)>>h,0x09)^mod_mult((s[3]&m)>>h,0x0e))<<h;
      m <<= 8; h+=8;
   }
   s[0] = o[0]; s[1] = o[1]; s[2] = o[2]; s[3] = o[3];
}

void key_expansion(uint32_t * k, uint32_t * w, uint8_t Nk, uint8_t Nr) {
   static const uint32_t Rcon[14] = { 0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,
                                      0x20000000,0x40000000,0x80000000,0x1b000000,0x36000000,
                                      0x6c000000,0xd8000000,0xd8000000,0xb0000000};
   uint8_t i = 0;
   uint32_t temp;
   while (i < Nk) {
      w[i] = k[i]; i++;
   }
   while (i <= (4*Nr)+3) {
     temp = w[i-1];
     if (!(i % Nk)) {
        temp = ROTWORD(temp);
        temp = SUBWORD(temp);
        temp ^= Rcon[i/Nk-1];
     }
     else if (Nk > 6 && i % Nk == 4) {
        temp = SUBWORD(temp);
     }
     w[i] = (w[i-Nk] ^ temp);
     i++;
   }
}

void eic_key_expansion(uint32_t * k, uint32_t * w, uint32_t * dw, uint8_t Nk, uint8_t Nr) {
   static const uint32_t Rcon[14] = { 0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,
                                      0x20000000,0x40000000,0x80000000,0x1b000000,0x36000000,
                                      0x6c000000,0xd8000000,0xd8000000,0xb0000000};
   uint8_t i = 0;
   uint32_t temp;
   while (i < Nk) {
      dw[i] = w[i] = k[i]; i++;
   }
   while (i <= (4*Nr)+3) {
      temp = w[i-1];
      if (!(i%Nk)) {
        temp = ROTWORD(temp);
        temp = SUBWORD(temp);
        temp ^= Rcon[i/Nk-1];
      }
      else if (Nk > 6 && i % Nk == 4) {
         temp = SUBWORD(temp);
      }
      w[i] = (w[i-Nk] ^ temp);
      dw[i] = w[i];
      i++;
   }
   uint32_t temp1[4]={0,0,0,0};
   for (i = 1; i < Nr; i++) {
      load_state(temp1,dw+(i*4));
      inv_mix_columns(temp1);
      load_state(dw+(i*4),temp1);
   }
}

inline void xor_keys(uint32_t * s, uint32_t * k) {
   s[0] ^= (k[0]&0xff000000)|(k[1]&0xff000000)>>8|(k[2]&0xff000000)>>16|(k[3]&0xff000000)>>24;
   s[1] ^= (k[0]&0x00ff0000)<<8|(k[1]&0x00ff0000)|(k[2]&0x00ff0000)>>8|(k[3]&0x00ff0000)>>16;
   s[2] ^= (k[0]&0x0000ff00)<<16|(k[1]&0x0000ff00)<<8|(k[2]&0x0000ff00)|(k[3]&0x0000ff00)>>8;
   s[3] ^= (k[0]&0x000000ff)<<24|(k[1]&0x000000ff)<<16|(k[2]&0x000000ff)<<8|(k[3]&0x000000ff);
}

void print_matrix(uint32_t * block) {
   printf("| %02X %02X %02X %02X |\n",(block[0]&0xff000000)>>24,(block[0]&0x00ff0000)>>16,(block[0]&0x0000ff00)>>8,(block[0]&0x000000ff));
   printf("| %02X %02X %02X %02X |\n",(block[1]&0xff000000)>>24,(block[1]&0x00ff0000)>>16,(block[1]&0x0000ff00)>>8,(block[1]&0x000000ff));
   printf("| %02X %02X %02X %02X |\n",(block[2]&0xff000000)>>24,(block[2]&0x00ff0000)>>16,(block[2]&0x0000ff00)>>8,(block[2]&0x000000ff));
   printf("| %02X %02X %02X %02X |\n\n",(block[3]&0xff000000)>>24,(block[3]&0x00ff0000)>>16,(block[3]&0x0000ff00)>>8,(block[3]&0x000000ff));
}

void cipher(uint32_t * block, uint8_t Nr, uint32_t * w) {
   uint32_t state[4];
   uint8_t i;
   for (i = 0; i < 4; i++) block[i]^=w[i];
   load_state(block,state);
   for (i = 1; i < Nr; i++) {
      SUBBYTES(state);
      SHIFTROWS(state);
      mix_columns(state);
      xor_keys(state,w+(i*4));

   }
   SUBBYTES(state);
   SHIFTROWS(state);
   xor_keys(state,w+(i*4));

   load_state(state,block);
}

void inv_cipher(uint32_t * block, uint8_t Nr, uint32_t * w) {
   uint32_t state[4];
   uint8_t i;
   for (i = 0; i < 4; i++) block[i]^=w[(4*Nr)+i];
   load_state(block,state);
   for (i = Nr-1; i > 0; i--) {
      INVSHIFTROWS(state);
      INVSUBBYTES(state);
      xor_keys(state,w+(i*4));
      inv_mix_columns(state);
   }
   INVSHIFTROWS(state);
   INVSUBBYTES(state);
   xor_keys(state,w);

   load_state(state,block);
}

void eq_inv_cipher(uint32_t * block, uint8_t Nr, uint32_t * dw) {
   uint32_t state[4];
   uint8_t i;
   for (i = 0; i < 4; i++) block[i]^=dw[(4*Nr)+i];
   load_state(block,state);
   for (i = Nr-1; i > 0; i--) {
      INVSUBBYTES(state);
      INVSHIFTROWS(state);
      inv_mix_columns(state);
      xor_keys(state,dw+(i*4));
   }
   INVSUBBYTES(state);
   INVSHIFTROWS(state);
   xor_keys(state,dw+(i*4));

   load_state(state,block);
}

void generate_keys_AES(uint32_t * k, uint32_t * w) {
   key_expansion(k,w,8,14);
}

void encrypt_AES(uint32_t * block, uint32_t * w) {
   cipher(block,14,w);
}

void decrypt_AES(uint32_t * block, uint32_t * w) {
   inv_cipher(block,14,w);
}

/*
int main(void) {

   uint32_t I[4] = { 0x3243f6a8, 0x885a308d, 0x313198a2, 0xe0370734 };
   uint32_t k[8] = { 0x603deb10, 0x15ca71be, 0x2b73aef0, 0x857d7781,
                     0x1f352c07, 0x3b6108d7, 0x2d9810a3, 0x0914dff4};
   uint32_t w[59];
   uint32_t dw[59];

   
   eic_key_expansion(k,w,dw,8,14);
   print_matrix(I);
   cipher(I,14,w);
   print_matrix(I);
   printf("========================================================\n");
   eq_inv_cipher(I,14,dw);
   print_matrix(I);

   return 0;
}
*/
